/*******************************************************************************
 * Copyright (c) 2020 CentraleSupélec.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *******************************************************************************/
package org.eventb.theory.tests.rbp.tactics;

import org.eventb.core.ast.extension.IOperatorProperties.FormulaType;
import org.eventb.core.ast.extension.IOperatorProperties.Notation;
import org.eventb.theory.core.IDirectOperatorDefinition;
import org.eventb.theory.core.INewOperatorDefinition;
import org.eventb.theory.core.IProofRulesBlock;
import org.eventb.theory.core.IRewriteRule;
import org.eventb.theory.core.IApplicabilityElement.RuleApplicability;
import org.eventb.theory.rbp.tactics.RewritesManualTactic;
import org.eventb.theory.tests.rbp.reasoners.TheoryUtils;
import org.junit.Test;
import org.rodinp.core.RodinDBException;

/**
 * Tests the {@link RewritesManualTactic} tactic provider.
 *
 * @author Guillaume Verdier
 */
public class RewritesManualTacticTests extends AbstractTacticTests {

	/**
	 * Initializes {@link AbstractTacticTests#tacticProvider} to the tested tactic
	 * provider.
	 */
	public RewritesManualTacticTests() {
		tacticProvider = new RewritesManualTactic();
	}

	/**
	 * Creates the operators and rules used by the tests.
	 *
	 * This creates:
	 * <ul>
	 * <li>operator {@code ident(x) = x}</li>
	 * <li>operator {@code plusOne(x) = x + 1</li>
	 * <li>rewrite rule {@code x + x} to {@code 2 ∗ x}</li>
	 * <li>rewrite rule {@code x − x} to {@code 0}</li>
	 * </ul>
	 */
	protected void createTestDefinitions() throws RodinDBException {
		// ident(x) = x
		INewOperatorDefinition opIdent = TheoryUtils.createOperator(theoryRoot, "ident", false, false,
				FormulaType.EXPRESSION, Notation.PREFIX, null, null);
		TheoryUtils.createArgument(opIdent, "x", "ℤ", null, null);
		opIdent.createChild(IDirectOperatorDefinition.ELEMENT_TYPE, null, null).setFormula("x", null);

		// plusOne(x) = x + 1
		INewOperatorDefinition opPlusOne = TheoryUtils.createOperator(theoryRoot, "plusOne", false, false,
				FormulaType.EXPRESSION, Notation.PREFIX, null, null);
		TheoryUtils.createArgument(opPlusOne, "x", "ℤ", null, null);
		opPlusOne.createChild(IDirectOperatorDefinition.ELEMENT_TYPE, null, null).setFormula("x + 1", null);

		IProofRulesBlock proofRules = TheoryUtils.createProofRulesBlock(theoryRoot, "Rewrite Tactic Tests", null);
		TheoryUtils.createMetavariable(proofRules, "x", "ℤ", null);

		// rewrite x + x to 2 * x
		IRewriteRule ruleDouble = TheoryUtils.createAutoRewriteRule(proofRules, "additionDouble", "x + x", true,
				RuleApplicability.INTERACTIVE, "Double integer rewrite", null);
		TheoryUtils.createRewriteRuleRHS(ruleDouble, "multiplicationDouble", "⊤", "2 ∗ x", null);

		// rewrite x - x to 0
		IRewriteRule ruleSubtract = TheoryUtils.createAutoRewriteRule(proofRules, "subtractSame", "x − x", true,
				RuleApplicability.INTERACTIVE, "Self subtraction rewrite", null);
		TheoryUtils.createRewriteRuleRHS(ruleSubtract, "zero", "⊤", "0", null);
	}

	/**
	 * Creates a theorem and checks the results of the applications generated by the
	 * tactic provider.
	 *
	 * The theorem can use the operators defined in
	 * {@link #createTestDefinitions()}.
	 *
	 * The tactic provider will try to apply the rewrite rules defined in
	 * {@link #createTestDefinitions()}.
	 *
	 * @param theorem          the definition of the theorem to use for the test
	 * @param hypothesis       if {@code true}, the test will use the first
	 *                         hypothesis of the theorem, otherwise the test will
	 *                         use the goal
	 * @param expectedSequents the lists of sequents obtained after applying each
	 *                         application generated by the tactic provider
	 * @see AbstractTacticTests#checkTacticsApplication(String, String, boolean,
	 *      String[]...)
	 */
	protected void testTheorem(String theorem, boolean hypothesis, String[]... expectedSequents) throws Exception {
		createTestDefinitions();
		TheoryUtils.createTheorem(testTheoryRoot, "thm1", theorem, null);
		buildAndDeploy();
		checkTacticsApplication("org.eventb.theory.rbp.RbP0", "thm1/S-THM", hypothesis, expectedSequents);
	}

	/* Basic case: no rewrites possible */

	/**
	 * Tests that nothing happens when no rewrites are possible in the goal.
	 */
	@Test
	public void test_noRewritesInGoal() throws Exception {
		testTheorem("0=0", false);
	}

	/**
	 * Tests that nothing happens when no rewrites are possible in the hypothesis.
	 */
	@Test
	public void test_noRewritesInHypothesis() throws Exception {
		testTheorem("0=0 ⇒ ⊤", true);
	}

	/* First set of tests: use rewrite rules generated from operators definitions */

	/**
	 * Tests a single rewrite in the goal.
	 */
	@Test
	public void test_operatorDefinitionRewrite_singleInGoal() throws Exception {
		testTheorem("ident(0)=0", false, new String[] { "{}[][][] |- ⊤", "{}[][][⊤] |- 0=0" });
	}

	/**
	 * Tests two rewrites of the same operator in the goal.
	 */
	@Test
	public void test_operatorDefinitionRewrite_twoInGoal() throws Exception {
		testTheorem("ident(0)=ident(0)", false, //
				new String[] { "{}[][][] |- ⊤", "{}[][][⊤] |- 0=ident(0)" },
				new String[] { "{}[][][] |- ⊤", "{}[][][⊤] |- ident(0)=0" });
	}

	/**
	 * Tests two rewrites of two different operators in the goal.
	 */
	@Test
	public void test_operatorDefinitionRewrite_twoDifferentInGoal() throws Exception {
		testTheorem("plusOne(0)=ident(1)", false, //
				new String[] { "{}[][][] |- ⊤", "{}[][][⊤] |- 0+1=ident(1)" },
				new String[] { "{}[][][] |- ⊤", "{}[][][⊤] |- plusOne(0)=1" });
	}

	/**
	 * Tests a single rewrite in the hypothesis.
	 */
	@Test
	public void test_operatorDefinitionRewrite_singleInHypothesis() throws Exception {
		testTheorem("ident(0)=0 ⇒ ⊤", true,
				new String[] { "{}[][][ident(0)=0] |- ⊤", "{}[ident(0)=0][][⊤;;0=0] |- ⊤" });
	}

	/**
	 * Tests two rewrites of the same operator in the hypothesis.
	 */
	@Test
	public void test_operatorDefinitionRewrite_twoInHypothesis() throws Exception {
		testTheorem("ident(0)=ident(0) ⇒ ⊤", true, //
				new String[] { "{}[][][ident(0)=ident(0)] |- ⊤", "{}[ident(0)=ident(0)][][⊤;;0=ident(0)] |- ⊤" },
				new String[] { "{}[][][ident(0)=ident(0)] |- ⊤", "{}[ident(0)=ident(0)][][⊤;;ident(0)=0] |- ⊤" });
	}

	/**
	 * Tests two rewrites of two different operators in the hypothesis.
	 */
	@Test
	public void test_operatorDefinitionRewrite_twoDifferentInHypothesis() throws Exception {
		testTheorem("plusOne(0)=ident(1) ⇒ ⊤", true, //
				new String[] { "{}[][][plusOne(0)=ident(1)] |- ⊤", "{}[plusOne(0)=ident(1)][][⊤;;0+1=ident(1)] |- ⊤" },
				new String[] { "{}[][][plusOne(0)=ident(1)] |- ⊤", "{}[plusOne(0)=ident(1)][][⊤;;plusOne(0)=1] |- ⊤" });
	}

	/* Second set of tests: use user-defined rewrite rules */

	/**
	 * Tests a single rewrite in the goal.
	 */
	@Test
	public void test_ruleRewrite_singleInGoal() throws Exception {
		testTheorem("1+1=2", false, new String[] { "{}[][][] |- ⊤", "{}[][][⊤] |- 2∗1=2" });
	}

	/**
	 * Tests two rewrites of the same operator in the goal.
	 */
	@Test
	public void test_ruleRewrite_twoInGoal() throws Exception {
		testTheorem("1+1=1+1", false, //
				new String[] { "{}[][][] |- ⊤", "{}[][][⊤] |- 2∗1=1+1" },
				new String[] { "{}[][][] |- ⊤", "{}[][][⊤] |- 1+1=2∗1" });
	}

	/**
	 * Tests two rewrites of two different operators in the goal.
	 */
	@Test
	public void test_ruleRewrite_twoDifferentInGoal() throws Exception {
		testTheorem("0+0=1−1", false, //
				new String[] { "{}[][][] |- ⊤", "{}[][][⊤] |- 2∗0=1−1" },
				new String[] { "{}[][][] |- ⊤", "{}[][][⊤] |- 0+0=0" });
	}

	/**
	 * Tests a single rewrite in the hypothesis.
	 */
	@Test
	public void test_ruleRewrite_singleInHypothesis() throws Exception {
		testTheorem("1+1=2 ⇒ ⊤", true, new String[] { "{}[][][1+1=2] |- ⊤", "{}[1+1=2][][⊤;;2∗1=2] |- ⊤" });
	}

	/**
	 * Tests two rewrites of the same operator in the hypothesis.
	 */
	@Test
	public void test_ruleRewrite_twoInHypothesis() throws Exception {
		testTheorem("1+1=1+1 ⇒ ⊤", true, //
				new String[] { "{}[][][1+1=1+1] |- ⊤", "{}[1+1=1+1][][⊤;;2∗1=1+1] |- ⊤" },
				new String[] { "{}[][][1+1=1+1] |- ⊤", "{}[1+1=1+1][][⊤;;1+1=2∗1] |- ⊤" });
	}

	/**
	 * Tests two rewrites of two different operators in the hypothesis.
	 */
	@Test
	public void test_ruleRewrite_twoDifferentInHypothesis() throws Exception {
		testTheorem("0+0=1−1 ⇒ ⊤", true, //
				new String[] { "{}[][][0+0=1−1] |- ⊤", "{}[0+0=1−1][][⊤;;2∗0=1−1] |- ⊤" },
				new String[] { "{}[][][0+0=1−1] |- ⊤", "{}[0+0=1−1][][⊤;;0+0=0] |- ⊤" });
	}

}
