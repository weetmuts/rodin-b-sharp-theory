### Theory Core static checker plugin messages

### build
build_cleaning= Cleaning {0}
build_runningSC= Analysing {0}
build_extracting= Extracting {0}
### progress messages
progress_TheoryImportTheories = [Processing theory import directives]
progress_TheoryTypeParameters = [Processing theory type parameters]
progress_TheoryDatatypes =  [Processing theory datatypes]
progress_TheoryOperators = [Processing theory operators]
progress_TheoryProofRules = [Processing theory proof rules]
progress_TheoryInferenceRules = [Processing theory inference rules]
progress_TheoryRewriteRules = [Processing theory proof rules]
progress_TheoryTheorems = [Processing theory theorems]

### Graph problems
scuser_DatatypeNameAlreadyATypeParError = Datatype {0} name is a type parameter
scuser_ConstructorNameAlreadyATypeParError = Constructor {0} name is a type parameter
scuser_DestructorNameAlreadyATypeParError = Destructor {0} name is a type parameter
scuser_InadmissibleDatatypeError = Datatype inadmissible: ({0}) type of destructor inadmissible
scuser_MissingDestructorNameError = Missing destructor name
scuser_MissingConstructorNameError = Missing constructor name
scuser_MissingDatatypeNameError = Missing datatype name
scuser_MissingDestructorTypeError = Missing type for destructor {0}
scuser_TypeArgMissingError = Type argument missing for datatype {0}
scuser_TypeIsNotRefTypeError = Type {0} is not added as a type argument
scuser_TypeArgNotDefinedError = Type argument {0} not defined
scuser_TypeArgRedundWarn = Type argument {0} redundant
scuser_DatatypeHasNoConsError = Datatype {0} has no element constructors
scuser_IdenIsADatatypeNameError = Identifier {0} is an existing datatype name
scuser_IdenIsAConsNameError = Identifier {0} is an existing datatype constructor name
scuser_IdenIsADesNameError = Identifier {0} is an existing datatype destructor name
scuser_DatatypeHasNoBaseConsError = Datatype {0} has no base constructors
scuser_MissingOpLabelIDError = Missing operator ID
scuser_OperatorIDConflictError = Ambiguous operator ID {0}
scuser_OperatorIDExistsError = There is already an operator with ID {0}
scuser_OperatorSynMissingError = Syntax symbol missing for {0}
scuser_OperatorSynExistsError = There is already an operator with syntax symbol {0}
scuser_OperatorFormTypeMissingError = Formula type attribute missing for {0}
scuser_OperatorNotationTypeMissingError = Notation type attribute missing for {0}
scuser_OperatorAssocMissingWarning = Associativity attribute missing for {0}
scuser_OperatorCommutMissingWarning = Commutativity attribute missing for {0}
scuser_TypeAttrMissingError=Type missing for {0}
scuser_IdentIsNotTypeParError = Identifier {0} is not a type parameter
scuser_OperatorCannotBeCommutError= Operator {0} cannot be commutative
scuser_OperatorCannotBeAssosError= Operator {0} cannot be associative
scuser_WDPredMissingError=Well-definedness predicate missing
scuser_OpCannotReferToTheseIdents= Cannot refer to identifiers ({0})
scuser_OperatorSynIsATypeParError = Operator syntax symbol {0} is a type parameter 
scuser_OperatorHasMoreThan1DefError = Operator {0} has more than one definition
scuser_MissingFormulaError=Missing formula attribute
scuser_OperatorHasNoDefError=Operator {0} has no definition
scuser_OperatorDefNotExpError = Operator {0} definition not an expression
scuser_OperatorDefNotPredError = Operator {0} definition not a predicate
scuser_OperatorWithSameSynJustBeenAddedError=Operator with syntax symbol {0} has just been added
scuser_OperatorInvalidSynError = Token ({0}) is not a valid syntax symbol
scuser_RulesBlockLabelProblemError = Ambiguous rules block label {0}
scuser_RulesBlockLabelProblemWarning = Ambiguous rules block label {0}
scuser_TheoremLabelProblemError = Ambiguous theorem label {0}
scuser_TheoremLabelProblemWarning = Ambiguous theorem label {0}
scuser_TheoremPredMissingError = Predicate missing for theorem {0}
scuser_NonTypeParOccurError= Type ({0}) not defined as a type parameter
scuser_TheoryInImportMissing = Target for theory import missing
scuser_ImportTheoryNotExist = Target ({0}) of import does not exist
scuser_RedundantImportWarning=Target ({0}) of import is redundant. Target ignored.
scuser_IndRedundantImportWarn = Import target is redundant. Ignored.
scuser_ImportDepCircularity = Import Circularity. Target of import ({0}) depends on current theory ({1}).
scuser_ImportConflict = Import conflict between hierarchy with leaf theory {0} and hierarchy with leaf theory {1}.
scuser_OperatorPredOnlyPrefix = Predicate operator can only be prefix
scuser_OperatorCannotBePostfix = Postfix operator notation not supported
scuser_OperatorPredNeedOneOrMoreArgs = Predicate operator needs at least one argument
scuser_OperatorExpInfixNeedsAtLeastTwoArgs= Infix expression operator needs at least two arguments
scuser_OperatorExpPrefixCannotBeAssos = Prefix expression operator cannot be associative
scuser_OperatorPredCannotBeAssos = Predicate operator cannot be associative
scuser_OperatorExpCannotBePostfix = Expression operator cannot be postfix
scuser_InductiveArgMissing = Inductive argument missing
scuser_ArgumentNotExistOrNotParametric = Argument ({0}) does not exist or is not inductive
scuser_InductiveCaseMissing = Inductive case missing
scuser_NoRecCasesError = Recursive definition has no cases
scuser_InductiveCaseNotAppropriateExp = Expression ({0}) not appropriate inductive case
scuser_IdentCannotBeUsedAsConsArg = Identifier ({0}) cannot be used as a constructor argument
scuser_UnableToTypeCase = Unable to type inductive case
scuser_RecCaseAlreadyCovered = Inductive case already covered
scuser_TypeMissmatchOfRecDef = Type mismatch
scuser_NoCoverageAllRecCase = Not all inductive cases are covered
scuser_RecOpTypeNotConsistent = Recursive definition type not consistent {0} and {1}
scuser_ConsArgNotIdentInCase = Constructor argument ({0}) supposed to be an identifier
scuser_ExprIsNotDatatypeConstr = Expression is not a datatype constructor
scuser_ConstrAlreadyCovered = Inductive case redundant
scuser_ExprNotApproInductiveCase = Expression not appropriate inductive case
scuser_ConstrArgumentNotIdentifier = Constructor argument ({0}) not an appropriate identifier

scuser_OpArgExprNotSet = Expression ({0}) not a set
scuser_UntypedTypeParameterError= Internal error. Type parameter {0} does not have a type
scuser_UntypedMetavariableError= Internal error. Metavariable {0} does not have a type
scuser_UntypedOperatorArgumentError = Internal error. Operator argument {0} does not have a type
scuser_OperatorArgumentNameConflict = Ambiguous declaration of operator argument {0}
scuser_TypeParameterNameConflict=Ambiguous declaration of type parameter {0}
scuser_MetavariableNameConflictError=Ambiguous declaration of metavariable {0}
scuser_RhsLabelConflict = Ambiguous rule side label {0}
scuser_LHSUndef= Left hand side formula missing
scuser_RHSFormulaMissing=Right hand side formula missing
scuser_CondUndef = Right hand side condition missing
scuser_CondAttrUndef = Rule conditional attribute missing
scuser_RewriteRuleLabelConflict= Ambiguous rewrite rule label {0}
scuser_InferenceRuleLabelConflict = Ambiguous inference rule label {0}
scuser_InferenceRuleNotApplicableError= Inference rule {0} may not be applicable: either given clauses or infer clauses should include all identifiers
scuser_RuleInfersError=Inference rule {0} must have one infer clause

scuser_InferenceGivenBTRUEPredWarn = True predicate ignored in given clause
scuser_InferenceInferBTRUEPredErr = True predicate not allowed in infer clause
scuser_InferenceRuleBackward = Rule {0} can be used for backward reasoning
scuser_InferenceRuleForward = Rule {0} can be used for forward reasoning
scuser_InferenceRuleBoth = Rule {0} can be used for forward and backward reasoning 

scuser_ApplicabilityUndefError=Rule applicability missing

scuser_RHSIdentsNotSubsetOfLHSIdents = Rule right hand side ({0}) rhs contains identifiers not present in lhs
scuser_CondIdentsNotSubsetOfLHSIdents = Rule right hand side ({0}) condition contains identifiers not present in lhs
scuser_CondTypesNotSubsetOfLHSTypes=Rule right hand side ({0}) condition refers to types not present in lhs
scuser_RHSTypesNotSubsetOfLHSTypes=Rule right hand side ({0}) rhs refers to types not present in lhs

scuser_RuleSideNotTheoryFormula = Side of rule neither predicate nor expression
scuser_LhsAndRhsNotSynClassMatching = Rule sides of different syntactic class: {0} and {1}
scuser_DescNotSupplied = Interactive rule {0} with missing description
scuser_CompleteUndefWarning = Rule complete attribute missing: set to incomplete
scuser_RuleTypeMismatch = Type mismatch of rule sides: {0} and {1}
scuser_RuleWithNoRHSs = Rule {0} requires right hand side
scuser_NoRuleDescWarning = Rule {0} description attribute missing
scuser_LHSIsIdentErr = Left hand side may not be metavariable or predicate variable
scuser_LHS_IsNotWDStrict = Left hand side may not be WD-strict
scuser_RHSPredVarsNOTSubsetOFLHS = Right hand side contains predicate variables not present in the left hand side

database_SCTypeParseFailure = Error parsing statically checked type in {0}
