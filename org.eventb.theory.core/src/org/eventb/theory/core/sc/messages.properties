### Theory Core static checker plugin messages

### build
build_cleaning= Cleaning {0}
build_runningSC= Analysing {0}
build_extracting= Extracting {0}
### progress messages
progress_TheoryTypeParameters = [Processing theory type parameters]
progress_TheoryDatatypes =  [Processing theory datatypes]
progress_TheoryOperators = [Processing theory operators]
progress_TheoryProofRules = [Processing theory proof rules]
progress_TheoryInferenceRules = [Processing theory inference rules]
progress_TheoryRewriteRules = [Processing theory proof rules]
progress_TheoryTheorems = [Processing theory theorems]
### Graph problems
scuser_DatatypeNameAlreadyATypeParError = Datatype {0}`s name is a type parameter
scuser_ConstructorNameAlreadyATypeParError = Constructor {0}`s name is a type parameter
scuser_DestructorNameAlreadyATypeParError = Destructor {0}`s name is a type parameter
scuser_MissingDestructorNameError = Missing destructor name
scuser_MissingConstructorNameError = Missing constructor name
scuser_MissingDatatypeNameError = Missing datatype name
scuser_MissingDestructorTypeError = Missing type for destructor {0}
scuser_TypeArgMissingError = Type argument missing for datatype {0}
scuser_TypeIsNotRefTypeError = Type {0} is not added as a type argument
scuser_TypeArgNotDefinedError = Type argument {0} not defined
scuser_TypeArgRedundWarn = Type argument {0} redundant
scuser_DatatypeHasNoConsError = Datatype {0} has no element constructors
scuser_IdenIsADatatypeNameError = Identifier {0} is an existing datatype name
scuser_IdenIsAConsNameError = Identifier {0} is an existing datatype constructor name
scuser_IdenIsADesNameError = Identifier {0} is an existing datatype destructor name
scuser_DatatypeHasNoBaseConsError = Datatype {0} has no base constructors
scuser_MissingOpLabelIDError = Missing operator ID
scuser_OperatorIDConflictWarning = Ambiguous operator ID {0}
scuser_OperatorIDConflictError = Ambiguous operator ID {0}
scuser_OperatorIDExistsError = There is already an operator with ID {0}
scuser_OperatorSynMissingError = Syntax symbol missing for {0}
scuser_OperatorSynExistsError = There is already an operator with syntax symbol {0}
scuser_OperatorFormTypeMissingError = Formula type attribute missing for {0}
scuser_OperatorNotationTypeMissingError = Notation type attribute missing for {0}
scuser_OperatorAssocMissingWarning = Associativity attribute missing for {0}
scuser_OperatorCommutMissingWarning = Commutativity attribute missing for {0}
scuser_TypeAttrMissingForOpArgError = Type missing for {0}
scuser_IdentIsNotTypeParError = Identifier {0} is not a type parameter
scuser_OperatorCannotBeCommutError= Operator {0} cannot be commutative
scuser_OperatorCannotBeAssosError= Operator {0} cannot be associative
scuser_WDPredUndefError = Well-definedness predicate missing
scuser_OpCannotReferToTheseTypes = Cannot refer to types ({0}) not used to type operator arguments
scuser_OperatorSynIsATypeParError = Operator syntax symbol {0} is a type parameter 
scuser_OperatorHasMoreThan1DirectDefError = Operator {0} has more than one direct definition
scuser_MissingFormulaAttrError =  Missing formula attribute
scuser_OperatorNoDirectDefError = Operator {0} has no definition
scuser_OperatorDefNotExpError = Operator {0} definition not an expression
scuser_OperatorDefNotPredError = Operator {0} definition not a predicate
scuser_OperatorWithSameSynJustBeenAdded = Operator with syntax symbol {0} has just been added
scuser_OperatorInvalidSynError = Token ({0}) is not a valid syntax symbol
scuser_RulesBlockLabelProblemError = Ambiguous rules block label {0}
scuser_RulesBlockLabelProblemWarning = Ambiguous rules block label {0}
scuser_TheoremLabelProblemError = Ambiguous theorem label {0}
scuser_TheoremLabelProblemWarning = Ambiguous theorem label {0}
scuser_TheoremPredMissingError = Predicate missing for theorem {0}
scuser_NonTypeParOccurError= Type ({0}) not defined as a type parameter
scuser_TheoryInImportMissing = Target for theory import missing
scuser_ImportTheoryNotExist = Target ({0}) of import does not exist
scuser_RedundantImportWarn = Target ({0}) of import is redundant because it is imported through ({1}). Target ignored.
scuser_OperatorPredOnlyPrefix = Predicate operator can only be prefix
scuser_OperatorPredNeedOneOrMoreArgs = Predicate operator needs at least one argument
scuser_OperatorExpInfixNeedsAtLeastTwoArgs= Infix expression operator needs at least two arguments
scuser_OperatorExpPrefixCannotBeAssos = Prefix expression operator cannot be associative
scuser_OperatorPredCannotBeAssos = Predicate operator cannot be associative
scuser_OperatorExpCannotBePostfix = Expression operator cannot be postfix

scuser_UntypedTypeParameterError= Internal error. Type parameter {0} does not have a type
scuser_UntypedMetavariableError= Internal error. Metavariable {0} does not have a type
scuser_UntypedOperatorArgumentError = Internal error. Operator argument {0} does not have a type
scuser_OperatorArgumentNameConflict = Ambiguous declaration of operator argument {0}
scuser_TheoryTypeParameterNameConflict= Ambiguous declaration of type parameter {0}
scuser_TheoryMetaVarNameConflict= Ambiguous declaration of metavariable {0}
scuser_RhsLabelConflict = Ambiguous rule side label {0}
scuser_LHSUndef= Left hand side formula missing
scuser_RHSUndef= Right hand side formula missing
scuser_CondUndef = Right hand side condition missing
scuser_CondAttrUndef = Rule conditional attribute missing
scuser_RewriteRuleLabelConflict= Ambiguous rewrite rule label {0}
scuser_InferenceRuleLabelConflict = Ambiguous inference rule label {0}
scuser_InferenceRuleNotApplicableError= Inference rule {0} may not be applicable: either given clauses or infer clauses should include all identifiers
scuser_RuleWithNoInfers= Inference rule {0} must have at least an infer clause
scuser_InferenceGivenBTRUEPredWarn = True predicate ignored in given clause
scuser_InferenceInferBTRUEPredErr = True predicate not allowed in infer clause
scuser_InferenceRuleBackward = Rule {0} can be used for backward reasoning
scuser_InferenceRuleForward = Rule {0} can be used for forward reasoning
scuser_InferenceRuleBoth = Rule {0} can be used for forward and backward reasoning 

scuser_RHSIdentsNotSubsetOfLHSIdents = Rule right hand side ({0}) rhs contains identifiers not present in lhs
scuser_CondIdentsNotSubsetOfLHSIdents = Rule right hand side ({0}) condition contains identifiers not present in lhs
scuser_CondGivensNotSubsetOfLHSGivens = Rule right hand side ({0}) condition refers to types not present in lhs
scuser_RHSGivensNotSubsetOfLHSGivens = Rule right hand side ({0}) rhs refers to types not present in lhs

scuser_RuleSideNotTheoryFormula = Side of rule neither predicate nor expression
scuser_LhsAndRhsNotSynClassMatching = Rule sides of different syntactic class: {0} and {1}
scuser_AutoUndefWarning = Rule automatic attribute missing: set to non-automatic
scuser_InterUndefWarning = Rule interactive attribute missing: set to interactive
scuser_ToolTipNotSupplied = Interactive rule {0} with missing tool tip
scuser_DescNotSupplied = Interactive rule {0} with missing description
scuser_CompleteUndefWarning = Rule complete attribute missing: set to incomplete
scuser_RuleTypeMismatch = Type mismatch of rule sides: {0} and {1}
scuser_RuleWithNoRHSs = Rule {0} requires right hand side
scuser_NoToolTipWarning = Rule {0} tool tip attribute missing
scuser_NoRuleDescWarning = Rule {0} description attribute missing
scuser_LHSIsIdentErr = Left hand side is a metavariable
scuser_RHSPredVarsNOTSubsetOFLHS = Right hand side contains predicate variables not present in the left hand side
